import ipaddress
from scapy.all import *
from queue import Queue
import socket

from core.modules import Exploit, Option


class Module(Exploit):
    def list_of_ports(x):
        return [int(n.strip()) for n in x.split(',')]

    options = {
            "RHOST": Option(None, True, "Remote host", type=ipaddress.ip_address),
            "THREADS": Option(1, False, "Number of threads to run", type=int),
            "PORT": Option([502], True, "Ports to scan", type=list_of_ports),
            "TIMEOUT": Option(5, True, "Timeout to wait for a reply", type=int),
            "REPORT_CLOSED": Option(False, False, "Toggle to report ports that are closed", type=bool),
            }

    results = []

    def syn_scan(self, rhost, queue, timeout):
        while not queue.empty():
            port = queue.get()
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(timeout)

                result = s.connect_ex((rhost, port))

                is_open = result == 0
                report_closed = self.get_option("REPORT_CLOSED")

                if report_closed or is_open:
                    self.results.append([rhost, port, "Open" if is_open else "Closed"])

            queue.task_done()

    def exploit(self):
        rhost = str(self.get_option("RHOST"))
        thread_count = self.get_option("THREADS")
        timeout = self.get_option("TIMEOUT")

        queue = Queue()
        for p in self.get_option("PORT"):
            queue.put(p)

        threads = []
        for _ in range(thread_count):
            thread = threading.Thread(target=self.syn_scan, args=(rhost, queue, timeout))
            threads.append(thread)
            thread.start()

        for thread in threads:
            thread.join()
