import ipaddress
from scapy.all import *
from queue import Queue
import socket

from core.modules import Exploit, Option
from core.reports import Report

class Module(Exploit):
    def list_of_ports(x):
        if '-' in x:
            # treat it as a range
            parts = x.split('-')
            if len(parts) != 2:
                raise ValueError("Malformed range")

            min = int(parts[0])
            max = int(parts[1])

            return range(min, max)

        return [int(n.strip()) for n in x.split(',')]

    name = "SYN scan for open ports"
    desc = "Sends SYN packets to establish a connection and detect open ports"
    severity = 3

    options = {
            "RHOST": Option(None, True, "Remote host", type=ipaddress.ip_address),
            "THREADS": Option(1, False, "Number of threads to run", type=int),
            "PORT": Option([502], True, "Ports to scan", type=list_of_ports),
            "TIMEOUT": Option(5, True, "Timeout to wait for a reply", type=int),
            "REPORT_CLOSED": Option(False, False, "Toggle to report ports that are closed", type=bool),
            }

    results = []

    def write_report(self, report: Report):
        self.results.sort(key=lambda x: x[1]) # sort by the port
        mitigation = [
                "Apply a filter to block malicious traffic",
                "Enforce whitelisting to prevent unknown devices from connecting",
                "Close all unused open ports",
                ]

        (
            report
                .heading(self.name)
                .paragraph("Severity: " + str(self.severity))
                .paragraph(self.desc)
                .paragraph("Scanned " + str(len(self.get_option("PORT"))) + " ports")
        )
        if self.results:
            report.found_something = True
            (
                report
                    .paragraph(report.bold("Mitigation strategies:"))
                    .list(mitigation)
                    .table(["Host", "Port", "Status"], self.results)
            )
        else:
            report.paragraph("No results to report")


    def syn_scan(self, rhost, queue, timeout):
        while not queue.empty():
            port = queue.get()
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(timeout)

                result = s.connect_ex((rhost, port))

                is_open = result == 0
                report_closed = self.get_option("REPORT_CLOSED")

                if report_closed or is_open:
                    print(rhost, port, "Open" if is_open else "Closed")
                    self.results.append([rhost, port, "Open" if is_open else "Closed"])

            queue.task_done()

    def exploit(self):
        self.results = []

        rhost = str(self.get_option("RHOST"))
        thread_count = self.get_option("THREADS")
        timeout = self.get_option("TIMEOUT")

        queue = Queue()
        for p in self.get_option("PORT"):
            queue.put(p)

        threads = []
        for _ in range(thread_count):
            thread = threading.Thread(target=self.syn_scan, args=(rhost, queue, timeout))
            threads.append(thread)
            thread.start()

        for thread in threads:
            thread.join()
