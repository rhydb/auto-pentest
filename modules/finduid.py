from scapy.all import *
from scapy.layers.inet import report_ports
import scapy.contrib.modbus as modbus
import socket

from queue import Queue
import threading

import ipaddress
from tabulate import tabulate

from core.modules import Exploit, Option
from core.reports import Report

transId = 1
timeout = 5

def getTransId():
	global transId
	transId = transId + 1
	if transId > 65535:
		transId = 1
	return transId

class Module(Exploit):
    desc = "Finds UIDs available on a Modbus host"
    options = {
            "RHOST": Option(None, True, "Remote host", type=ipaddress.ip_address),
            "UID_FROM": Option(0, False, "Start UID", type=int),
            "UID_TO": Option(255, False, "End UID", type=int),
            "THREADS": Option(1, False, "Number of threads to run", type=int),
            }
    port = 502
    timeout = 5

    con = None

    severity = 9

    uids = []

    def write_report(self, report: Report):
        mitigation = [
                "Implement a firewall",
                "Use a VPN to encrypt communication across networks",
                "Isolate the Modbus network"
                ]

        _ = report\
                .heading("UIDs")\
                .paragraph("Severity: " + str(self.severity))\
                .paragraph(self.desc)\
                .paragraph("Mitigation strategies:")\
                .list(mitigation)\
                .table(["UID"], self.uids)

    def is_valid(self):
        if not super().is_valid():
            return False

        if self.options["UID_FROM"].value > self.options["UID_TO"].value:
            print("UID_FROM must be less than UID_TO")
            return False
        return True

    def try_uid(self, rhost, uid):
        with socket.socket() as s:
            try:
                s.connect((rhost, self.port))
            except ConnectionRefusedError:
                print("connection refused")
                return

            # todo: bind to source ip
            con = StreamSocket(s, Raw)

            transId = getTransId()
            ans = con.sr1(
                    modbus.ModbusADURequest(transId=transId, unitId=uid) / modbus.ModbusPDU04ReadInputRegistersRequest(),
                    timeout=timeout, verbose=0)

            if ans:
                first_four = bytes(ans)[:4]
                expected = transId.to_bytes(2) + bytes(2) # trans id + protocol id, modbus protocol id is always \x00\x00
                if first_four == expected:
                    self.uids.append([uid])
                    print("UID up:", uid)


    def worker(self, rhost, queue):
        while not queue.empty():
            uid = queue.get()
            self.try_uid(rhost, uid)
            queue.task_done()

    def exploit(self):
        self.uids = []

        try:
            rhost = str(self.get_option("RHOST"))
        except KeyError:
            print("RHOST is required")
            return

        thread_count = self.get_option("THREADS")

        queue = Queue()
        for i in range(self.options["UID_FROM"].value, self.options["UID_TO"].value):
            queue.put(i)

        threads = []
        for _ in range(thread_count):
            thread = threading.Thread(target=self.worker, args=(rhost, queue,))
            thread.start()
            threads.append(thread)

        for thread in threads:
            thread.join()
