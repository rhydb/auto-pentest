import socket

from scapy.all import Raw, StreamSocket
from core.modules import Exploit, Option, Likelihood, Impact, text_color
from core.reports import Report
from core.parsers import parse_ip
from queue import Queue
import threading

class Module(Exploit):
    name = "Modbus host discovery"
    desc = "Discovers hosts running Modbus"

    likelihood = Likelihood.UNLIKELY
    impact = Impact.MAJOR

    def __init__(self):
        super().__init__()

        self.options = {
                "RHOSTS": Option(None, True, "Remote hosts", type=parse_ip),
                "PORT": Option(502, True, "Port to scan for Modbus", type=int),
                "THREADS": Option(1, True, "Number of threads to run", type=int),
                }

        self.hosts = []


    def write_report(self, report: Report):
        mitigation = [
                "Implement a firewall",
                "Use a VPN to encrypt communication across networks",
                "Isolate the Modbus network"
                ]

        (
            report
                .heading(self.name)
                .paragraph("Risk: " + report.background(self.severity_colour, report.colour(text_color(self.severity_colour), str(self.severity))))\
                .paragraph(self.desc)
        )

        if self.hosts:
            report.found_something = True
            (
                report
                    .paragraph("Mitigation strategies:")
                    .list(mitigation)
                    .table(["Host", "Port"], self.hosts)
            )
        else:
            report.paragraph("No results to report")

    def exploit(self):
        self.hosts = []

        rhosts = self.get_option("RHOSTS")
        port = self.get_option("PORT")

        thread_count = self.get_option("THREADS")

        queue = Queue()
        for ip in rhosts:
            queue.put(ip)

        threads = []
        for _ in range(thread_count):
            thread = threading.Thread(target=self.connect, args=(queue, port))
            threads.append(thread)
            thread.start()

        for thread in threads:
            thread.join()

        return self.hosts

    def connect(self, queue, port):
        while not queue.empty():
            rhost = queue.get()
            with socket.socket() as s:
                try:
                    s.connect((rhost, port))
                except ConnectionRefusedError:
                    continue

                con = StreamSocket(s, Raw)
                if con:
                    self.hosts.append([rhost, port])
                    print("Modbus active:", rhost + ":" + str(port))
